由于查询时间与查询时机器的各项性能有关，以下的查询时间均取多次查询中的最短时间
1.1查询表中所有字段
select * from city;(约0.0003s)
由于选出全部city中的字段，所以至少读取59行
explain语句显示操作预计从59条记录中取出

select * from shop;(约0.01s)
同上，至少读取1000行
explain语句显示操作预计读取1029行(这个值是估计值，每次重新连接后的值不同)

并且这两种查询由于必须读取全部数据，因此无法进行查询优化

1.2查询表中指定字段
select city_id,city from city;(约0.0003s)
需要浏览全部city元组，至少需读取59行
explain语句显示操作预计从59条记录中取出
即使对city字段加上索引也无法提高查询速度，因为无论如何都需要读取全部数据

select shop_id from shop;(约0.0009s)
需要浏览全部元组，至少需要1000行
explain语句显示使用了shop中的主键索引shop_id，但实际仍需要读取全部行，因为减少了许多返回的列，所以查询时间相比于1.1中减少了很多

select shop_id,`name`,description from shop;(约0.005s)
同样需要浏览1000行，由此可以看出在需要浏览相同行数的时候，返回的列数与执行时间正相关

对于需要返回一个字段全部数据的查询，添加索引并不能提高查询速度，因为无论如何都需要读取全部的数据，因此在查询中应尽量避免这种查询

1.3查询表中没有重复的字段（distinct）的使用

select distinct(area) from shop;(约0.005s)
由于在area上不存在索引，因此需要浏览全部数据
explain语句显示由于distinct需要排序，因此使用了额外的表来排序，加长了查询时间
优化：可对area字段加上索引，此时查询时间缩短到约0.003s,explain语句显示没有使用额外表来排序，而是使用了索引，预计读取行数也少于全部

1.4条件查询各表主键的字段（单值查询或范围查询）
select `name` from shop where shop_id>10016726 and shop_id<10021920;(约0.0007s)
在shop_id上存在主键，因此这样的范围查询可直接使用索引，查询时间很短
explain语句显示使用了主键索引，读取了104行数据

在对主键字段进行查询时，因为在主键上均存在索引，这样的范围或单值查询速度会非常快

1.5条件查询各表中普通字段（单值查询或范围查询）
select shop_id,`name` from shop where small_cate='面包甜点';(约0.0015s)
由于在small_cate中不存在索引，在进行这样的范围查询时必须搜索全部记录，效率很低
explain语句显示查询使用了where，读取了全部数据，返回149条记录
优化：在small_cate上添加索引，之后查询时间缩短到小于0.001s，explain语句显示查询使用了索引，且只需要读取要返回的149条记录，因此时间大大缩短

select shop_id,`name` from shop where avg_price<20;(约0.0027s)
同上，在avg_price上没有索引，需要读取全部行,相比1.4中的范围查询慢了许多
优化：对avg_price创建索引，查询时间缩短到0.001s，同样只需读取与返回数相同数量的元组

由此可见，创建索引对于单值查询和范围查询有着比较好的效果，能够显著提高查询效率

1.6一个表中多个字段条件查询（单值查询或范围查询）
select shop_id,`name` from shop where small_cate='面包甜点' and avg_price<20;(约0.0013s)
small_cate与avg_price均不存在索引，需要读取全部行，再选出符合条件的元组，查询时间较长
优化：对所查询的字段增加索引，当对avg_price添加索引时，查询时间缩短到0.0009s，mydql会先对avg_price通过索引选出所用元组，再选择small_cate
若对small_cate添加索引，时间缩短到0.0007s，这是因为先选择small_cate符合条件的元组数目比avg_price小很多
若对small_cate和avg_price添加共同索引，查询时间降低到0.0006s左右，mysql直接访问索引然后读取符合条件的元组

因此对于单值或范围查询，应尽量使索引覆盖查询的字段，这样能够明显的缩短查询时间

1.7用”in”进行条件查询
此处与后文的exists查询一起讨论

1.8一个表中group by、order by、having联合条件查询
select small_cate,count(*) from shop where avg_price<20 group by small_cate;(约0.0015s)
mysql在处理group by时会建立一个临时表。然后利用mysql内部算法，算出来结果，但由于使用了临时表和排序，查询时间通常较长
explain语句显示using temporary，using filesort
优化：在这个查询语句之中，where部分和group by部分分别用了两个字段，因此只对其中一个字段加索引并不能有效提高查询效率，需要对avg_price,small_cate同时添加索引(avg_price,small_cate)，此时查询时间缩短到0.0007s左右，explain语句显示查询使用了索引，但没有使用临时表和排序，因此查询时间大大缩短
注意：group by对于1.对不同的索引键做group by(select * from a1 group by key1,key2;)
2.在非连续的索引键部分上做 group by(select * from t1 where key2=constant group by key_part2;)
3.where部分与group by部分不在同一索引中
这几种情况下不会使用索引，因此在数据库索引已经创建好之后，应尽量避免这一类的查询

select `name`,product_rating,avg_price from shop where small_cate='面包甜点' order by avg_price,product_rating;(约0.0016s)
在无索引情况下，mysql执行order by语句需要对order by进行排序，比较耗费时间
explain语句显示执行操作using filesort
优化：同group by，需要同时对where部分与order by部分添加索引，并且索引的顺序也十分重要，(avg_price,product_rating,small_cate)形式的索引几乎不能提高查询效率，而(small_cate,avg_price,product_rating)形式的索引可以将查询时间缩短到0.0009s左右
注意：同group by，对于以上几种情况以及在order by中同时使用了desc，asc时不会用到索引，查询效率提高较少

having和where的区别在于having可以用来筛选聚合后的数据，where在聚合之前进行筛选，这样的筛选并不会影响查询的速度，考虑以下两条语句
select small_cate,count(*) from shop where avg_price<20 group by small_cate;
select small_cate,count(*) from shop where avg_price<20 group by small_cate having count(*)>2;
这两条语句在查询速度上几乎相同，所以优化的主要部分在前面的操作上

2.1/2.2多表联合查询及join查询
select shop_id,`name`,city from shop,city where shop.city_id=city.city_id and avg_price<20;(约0.0024s)
对于上述查询，mysql会先将shop与city做笛卡尔积，再从中选择出符合条件的元组
优化：可以将选择操作提前到叉积之前，并且将叉积操作变为连接操作，这样可以减少连接的数量，也避免了大量的叉积操作，优化之后
select shop_id,`name`,city from (select shop_id,`name`,city_id from shop where avg_price<20) as A inner join city using(city_id);(约0.0015s)
可以看到查询时间缩短了很多，可以进一步优化，对avg_price添加索引，查询时间缩短到0.0013s左右，相比最初几乎快了一倍

select A.shop_id,A.`name` from shop as A,shop as B where A.`name`=B.`name` and A.city_id=1 and B.city_id=2;(约0.03s)
这样的查询对于此次的数据库中没有实用性的意义，但在其他的数据库中会经常碰到，这个操作需要将两个表做积，shop又有1000条记录，因此时间耗费很大，用了0.03s
优化：将查询操作提前到连接之前，并且用连接操作代替叉积操作，比如
select A.shop_id,A.`name` from (select shop_id,`name` from shop where city_id=1) as A inner join (select shop_id,`name` from shop where city_id=2) as B using(`name`);(约0.0015s)
查询效率提高非常多
由此可见，对于多个表的联合查询，除了对查询字段添加索引之外，还可以将查询操作提前到连接操作之前，并且避免使用直接的叉积操作，多用连接操作代替，可以大大提高查询效率


2.3存在量词（exist）查询
exists查询与in查询一起讨论，对于以下的查询语句
1.select * from A where exists (select * from B where B.id = A.id);
2.select * from A where A.id in (select id from B);
1会遍历A中每个元组，去查看exists条件是否满足，主要用到B中的索引，2则先查询子查询，再根据A中的索引去查看是否满足，在通常情况下，索引充足时，当A为大表时in效率较高，反之exists效率较高
对于not exists和not in查询
1.select * from A where not exists (select * from B where B.id = A.id);
2.select * from A where A.id not in (select id from B);
1查询同上，遍历A，而2此时在not in的查询则无法使用A中的索引，因此A的每条记录都要在B中遍历，此时not exists要比not in效率高
在实际操作中，应根据表中已有的索引情况以及各表的大小来选取exists与in
如：
select city from city where not exists(select 1 from shop where avg_price<100 and shop.city_id=city.city_id);(约0.0015s)
select city from city where city_id not in (select city_id from shop where avg_price<100);(约0.002s)

select shop_id,`name` from shop where city_id in(select city_id from city where city.city='长沙');(约0.001s)
select shop_id,`name` from shop where exists(select * from city where city.city='长沙' and city.city_id=shop.city_id);(约0.01s)


2.4嵌套子查询（select … from (select …)）


3.1/3.2向表中插入/删除记录
insert into shop(shop_id,`name`,city_id,avg_price) value(10000000,'计算机',1,50);
delete from shop where `name`='计算机';
当在city_id和avg_price上均不存在索引时插入时间最短
但如果在city_id或avg_price上存在索引的话插入时还需要根据插入的情况对索引进行调整，索引越多额外花费的时间就越多
删除操作首先需要找到所要删除的记录，因此删除时尽量通过搜索主键字段来删除，同样删除操作后也需要调整索引结构
所以在实际中应当权衡选择操作和插入/删除/修改操作，添加合适数量的索引，以达到最高的综合效率

3.3聚集函数
除上文讨论过的group by以外，常用的聚集函数还有max，min，count，avg，sum，对于min和max
select max(avg_price),min(avg_price) from shop where small_cate='面包甜点';
首先可以想到对搜索的字段加上索引，此时的查询速度有0.0006s左右，条件允许的情况下可建立(small_cate,avg_price)这样的索引，查询时间可以缩短到0.0002s
explain语句显示select tables optimized away,表示这个查询已经是最优情况
select count(*),sum(avg_price),avg(avg_price) from shop where small_cate='面包甜点';
同上，可对(small_cate,avg_price)添加索引，不同于max和min，count，sum和avg必须浏览所有符合条件的元组，查询时间在0.0004s左右
explain语句显示使用了索引，并且计划读取149行数据
